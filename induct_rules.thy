(*<*) theory induct_rules imports Main begin (*>*)

theorem merge_induct:  "(\<And>ys. P [] ys) \<Longrightarrow> (\<And>v va. P (v # va) []) \<Longrightarrow>
    (\<And>x xs y ys. (x \<le> y \<Longrightarrow> P xs (y # ys)) \<Longrightarrow> (\<not> x \<le> y \<Longrightarrow> P (x # xs) ys) \<Longrightarrow> P (x # xs) (y # ys)) \<Longrightarrow>
    P a0 a1" 
proof -
  assume 1: "\<And>ys. P [] ys "
  assume 2:" (\<And>v va. P (v # va) [])"
  assume 3:"(\<And>x xs y ys. (x \<le> y \<Longrightarrow> P xs (y # ys)) \<Longrightarrow> (\<not> x \<le> y \<Longrightarrow> P (x # xs) ys) \<Longrightarrow> P (x # xs) (y # ys))"
  show "P a0 a1" 
  proof (induction a0)
    case Nil
    then show ?case using 1 by auto
  next
    show "\<And>a a0. P a0 a1 \<Longrightarrow> P (a # a0) a1"
    proof (induct a1)
      case Nil
      then show ?case using 2 by auto
    next
      from 3 have new3: "(\<And>aa a0 a a1. (aa \<le> a \<Longrightarrow> P a0 (a # a1)) \<Longrightarrow> (\<not> aa \<le> a \<Longrightarrow> P (aa # a0) a1) \<Longrightarrow> P (aa # a0) (a # a1))" by simp
      show "\<And>a a1 aa a0. (\<And>a a0. P a0 a1 \<Longrightarrow> P (a # a0) a1) \<Longrightarrow> P a0 (a # a1) \<Longrightarrow> P (aa # a0) (a # a1)" 
      proof -
        fix a a1 aa a0
        assume 4:"(\<And>m n. P n a1 \<Longrightarrow> P (m # n) a1)"
        assume 5:" P a0 (a # a1)"
        show "P (aa # a0) (a # a1)"
        proof (cases)
          assume 6:"aa \<le>a"
          then show ?thesis
          proof -
            from new3 6 have "P a0 (a # a1) \<Longrightarrow>P (aa # a0) (a # a1) " by auto
            from this 5 show "P (aa # a0) (a # a1)" by auto
          qed
        next
          assume 7:"\<not> (aa \<le>a )"
          then show "P (aa # a0) (a # a1)"
          proof -
            from new3 7 have 8:" P (aa # a0) a1 \<Longrightarrow>P (aa # a0) (a # a1) "  by auto
            from 4 have "P a0 a1 \<Longrightarrow>P (aa#a0 ) a1" by auto 
            from this 8 have 9: "P a0 a1 \<Longrightarrow> P (aa#a0) (a#a1)" by auto
            from 4 have "P [] a1 \<Longrightarrow> P (aa#[]) a1" by auto
            from 4 have "\<And> ll. P ll a1"
            proof -
              fix ll 
              show "P ll a1"
              proof (induct ll)
                case Nil
                then show ?case using 1 by auto
              next
                case (Cons a ll)
                then show ?case using 4 by auto
              qed
            qed
            then have "P a0 a1" by auto
            from this 9 show "P (aa#a0) (a#a1)" by auto
          qed
        qed 
      qed
    qed
  qed
qed

(* theorem list_induct :" P [] \<Longrightarrow>  ( \<And> x a . P (x)  \<Longrightarrow>  P (a#x) )  \<Longrightarrow> P ll" sorry *)

theorem list_induct2: "P[] \<Longrightarrow>( \<And> x . P (x#[]) ) \<Longrightarrow>(\<And> x y a. (P (x#y)  \<Longrightarrow>P (a#x#y)) )  \<Longrightarrow> P ll" 
proof -
  assume 1:" P[]"
  assume 2:"( \<And> x . P (x#[]) )"
  assume 3:"(\<And> x y a. (P (x#y)  \<Longrightarrow>P (a#x#y)) ) "
  show "P ll" 
  proof (induct ll)
    case Nil
    then show ?case using 1 by auto
  next
    case (Cons a ll)
    then show ?case 
    proof (induct ll)
      case Nil
      then show ?case using 2 by auto
    next
      case (Cons a ll)
      then show ?case using 3 by auto
    qed
  qed
qed

lemma take_drop: " P  ( (take x ll) @ ( drop x ll) )  \<Longrightarrow>P ll " by auto


(*
lemma num_induct: "P (0::nat) \<Longrightarrow> P 1\<Longrightarrow> ( \<And> x . (P (x div 2) ) \<Longrightarrow> (P (x - (x div 2) ) \<Longrightarrow>P x) ) \<Longrightarrow>P num"
  sorry
*)

(*  generated by sledgehammer
by (metis diff_less div_2_gt_zero div_by_1 div_eq_0_iff div_eq_dividend_iff div_less_dividend div_self infinite_descent less_one linorder_neqE_nat nat_less_induct nat_neq_iff not_gr0 one_div_two_eq_zero one_neq_zero zero_not_eq_two)
*)

(* generated by sledgehammer,simplified 
 by (metis diff_less div_2_gt_zero div_eq_0_iff div_less_dividend infinite_descent less_one  nat_less_induct nat_neq_iff not_gr0 one_div_two_eq_zero zero_not_eq_two)
*)

(*  generated by sledgehammer
proof -
  assume a1: "P 0"
  assume a2: "P 1"
  assume "\<And>x. \<lbrakk>P (x div 2); P (x - x div 2)\<rbrakk> \<Longrightarrow> P x"
  then have f3: "\<forall>n na. \<not> P (na - na div 2) \<or> P na \<or> \<not> na div 2 < sK0 P \<or> P n"
    by (metis nat_less_induct) (* > 1.0 s, timed out *)
  have f4: "spl2_4 = (\<forall>X7. \<not> P (X7 - X7 div 2) \<or> \<not> X7 div 2 < sK0 P \<or> P X7)"
    by auto (* failed *)
  have f5: "spl2_0 = (\<forall>E_x. P E_x)"
    by auto (* failed *)
  have f6: "spl2_0 \<or> spl2_4"
    using f4 f3 by blast
  have f7: "\<forall>n na. \<not> 1 < n \<or> P na \<or> na div n < na"
    using a1 by (metis (no_types) div_less_dividend not_gr0)
  have "spl2_93 = (\<not> (1::nat) < 2)"
    by auto (* failed *)
  then have "\<not> spl2_93"
    by simp
  then have "spl2_4 \<and> spl2_92 \<or> spl2_0"
    using f6 by metis (* failed *)
  moreover
  { assume "spl2_4 \<and> spl2_92"
    moreover
    { assume "\<not> P (sK0 P) \<and> spl2_4 \<and> spl2_92"
moreover
{ assume "sK0 P div 2 < sK0 P \<and> \<not> P (sK0 P) \<and> spl2_4"
        moreover
        { assume "0 < sK0 P div 2 \<and> sK0 P div 2 < sK0 P \<and> \<not> P (sK0 P) \<and> spl2_4"
          moreover
          { assume "\<exists>n. 0 < sK0 P \<and> \<not> P (sK0 P - n) \<and> 0 < n"
            moreover
            { assume "\<exists>n. \<not> P (sK0 P - n) \<and> 0 < n \<and> (0::nat) < sK1 P"
              moreover
              { assume "\<exists>n. \<not> P (sK1 P - n) \<and> 0 < n \<and> 0 < sK1 P"
                then have "\<exists>n<sK1 P. \<not> P n"
                  by (meson diff_less)
                then have ?thesis
                  by (metis infinite_descent) (* > 1.0 s, timed out *) }
              ultimately have "sK0 P = sK1 P \<longrightarrow> P num"
                by (metis (no_types)) }
            ultimately have "sK0 P = sK1 P \<longrightarrow> P num"
              by (metis (no_types)) }
          ultimately have "sK0 P = sK1 P \<longrightarrow> P num \<or> P (sK1 P)"
            using f4 a1 by (metis (no_types) not_gr0) }
        moreover
        { assume "sK0 P \<noteq> sK1 P"
          moreover
          { assume "sK0 P < sK1 P"
            then have "P (sK0 P) \<or> P num"
              by (metis infinite_descent) (* > 1.0 s, timed out *) }
          moreover
          { assume "\<not> sK0 P < sK1 P \<and> sK0 P \<noteq> sK1 P"
            then have "sK1 P < sK0 P"
              by (meson nat_neq_iff)
            then have "P (sK1 P) \<or> P num"
              by (metis nat_less_induct) (* > 1.0 s, timed out *) }
          ultimately have "P (sK0 P) \<or> P (sK1 P) \<or> P num"
            by satx }
        moreover
        { assume "P (sK1 P)"
          then have ?thesis
            by (metis infinite_descent) (* > 1.0 s, timed out *) }
        ultimately have "P (sK0 P) \<or> P num"
          using a2 a1 by (metis (no_types) div_2_gt_zero less_one linorder_neqE_nat) }
      ultimately have "P (sK0 P) \<or> P num"
        using f7 by force }
    moreover
    { assume "P (sK0 P)"
      then have ?thesis
        by (metis nat_less_induct) (* > 1.0 s, timed out *) }
    ultimately have ?thesis
      by blast }
  ultimately show ?thesis
    using f5 by blast
qed
*)

lemma num_induct2_pre: "   ((\<And> n. (n::nat) < m \<Longrightarrow> P n) \<Longrightarrow>P m )\<Longrightarrow> (\<And> n::nat . n < m \<Longrightarrow> P n)  \<Longrightarrow> (\<And> n::nat . n < (Suc m) \<Longrightarrow> P n)  "
proof -
  fix m
  assume 1:"(\<And> n::nat . n < m \<Longrightarrow> P n)"
  assume 2:" (\<And> n. (n::nat) < m \<Longrightarrow> P n) \<Longrightarrow>P m"
  show 3:"(\<And> n::nat . n < (Suc m) \<Longrightarrow> P n)"
  proof -
    from 1 2 have " P m" by auto
    from this 1 less_le have "(\<And> n::nat . n \<le> m \<Longrightarrow> P n)" by metis
    from this less_le show "(\<And> n::nat . n < (Suc m) \<Longrightarrow> P n)" by auto
  qed
qed

lemma num_induct2_pre2: " (\<And> m .(\<And> n::nat . n < m \<Longrightarrow> P n) ) \<Longrightarrow> P all "
proof -
  assume 1:"(\<And> m .(\<And> n::nat . n < m \<Longrightarrow> P n) )"
  show "P all"
  proof (induct all)
    case 0
    from 1 show ?case by auto
  next
    case (Suc all)
    from 1 show ?case by auto 
  qed
qed

lemma num_induct2: " (\<And> m. (\<And> n. (n::nat) < m \<Longrightarrow> P n) \<Longrightarrow>P m )  \<Longrightarrow> P all"
proof - 
  assume 1:"(\<And> m. (\<And> n. (n::nat) < m \<Longrightarrow> P n) \<Longrightarrow>P m )"
  then have 2:"P 0" by auto
  from 1 num_induct2_pre have 3:"\<And> m. (\<And> n::nat . n < m \<Longrightarrow> P n)  \<Longrightarrow> (\<And> n::nat . n < (Suc m) \<Longrightarrow> P n)" by metis
  have 4: "\<And> m. (\<And> n::nat . n < m \<Longrightarrow> P n) "
  proof - 
    fix m
    show "(\<And> n::nat . n < m \<Longrightarrow> P n) "
    proof (induct m)
      case 0
      then show ?case by auto
    next
      case (Suc m)
      then show ?case
        using "1" 3 by metis
    qed
  qed
  from 4 num_induct2_pre2 show "P all" by auto
qed

lemma "(\<forall> n. ( A (n) \<longrightarrow>B ) ) = ((\<forall> n . A(n)) \<longrightarrow>B) "  (*this is not true*)
  oops

lemma "( \<forall> n.  B\<longrightarrow> A n ) = (B \<longrightarrow>(\<forall> n . A n) ) "  by auto

lemma num_induct3_pre: " P (0::nat) \<Longrightarrow> ( (\<And> n. (n::nat) < 0 \<Longrightarrow> P n) \<Longrightarrow>P 0 ) " by auto

lemma num_induct3_pre2: " P (0::nat) \<Longrightarrow>P(1) \<Longrightarrow> ( (\<And> n. (n::nat) < 1 \<Longrightarrow> P n) \<Longrightarrow>P 1 ) " by auto


lemma num_induct_pre: "(m::nat) \<ge>2 \<Longrightarrow>( \<And> x . (P (x div 2) ) \<Longrightarrow> (P (x - (x div 2) ) \<Longrightarrow>P x) ) \<Longrightarrow>  (\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m "
proof -
  assume 1:"m \<ge>2"
  assume 2:"( \<And> x . (P (x div 2) ) \<Longrightarrow> (P (x - (x div 2) ) \<Longrightarrow>P x) )" 
  assume 3:" (\<And> n. n  < m \<Longrightarrow> P n)"
  show "P m"
  proof -
    have 4:"(m div 2) < m" using 1 by auto
    have 5:"m - (m div 2) < m " using 1 by auto
    have 6:"(P (m div 2) ) \<Longrightarrow> (P (m - (m div 2) ) \<Longrightarrow>P m)" using 2 by metis
    from 3 4 have 7:" P (m div 2)" by auto
    from 3 5 have 8:"P (m - (m div 2) )" by auto
    from 6 7 8 show " P m" by auto
  qed
qed

lemma num_induct: "P (0::nat) \<Longrightarrow> P 1\<Longrightarrow> ( \<And> x . (P (x div 2) ) \<Longrightarrow> (P (x - (x div 2) ) \<Longrightarrow>P x) ) \<Longrightarrow>P num"
proof -
  assume 1:"P 0"
  assume 2:"P 1"
  assume 22:"( \<And> x . (P (x div 2) ) \<Longrightarrow> (P (x - (x div 2) ) \<Longrightarrow>P x) )"
  have "\<And> m. (\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m"
  proof -
    fix m 
    show "(\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m"
    proof (cases)
      assume 3:"m<2"
      show "(\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m" 
      proof (cases)
        assume "m = 0"
        from 1 this show "(\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m" by auto
      next
        assume "~ m= 0"
        from 3 this have "m =1" by auto
        from 2 this show "(\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m" by auto
      qed
    next
      assume "\<not> (m < 2)"
      from this have "m \<ge>2" by auto
      from this num_induct_pre have "( \<And> x . (P (x div 2) ) \<Longrightarrow> (P (x - (x div 2) ) \<Longrightarrow>P x) ) \<Longrightarrow>  (\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m" by metis
      from this 22 show "(\<And> n. n  < m \<Longrightarrow> P n) \<Longrightarrow>P m" by metis
    qed
  qed
  from this num_induct2 show " P num" by metis

qed



value " (1::nat) div 2"

lemma 
  fixes ll :: "nat list"  
  fixes n :: "nat"
shows "(\<And> n ll . (length(ll) = n  \<Longrightarrow>P(ll)) ) \<Longrightarrow> P all " by metis

(* " (\<And> m. (\<And> n. (n::nat) < m \<Longrightarrow> P n) \<Longrightarrow>P m )  \<Longrightarrow> P all" *)
lemma list_induct_pre:
  shows "  ( \<And> mm. (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm))  \<Longrightarrow> P []   "
proof -
  assume 1:"( \<And> mm. (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm))"
  have 2:"  (\<And> ll .length(ll) < (length [])   \<Longrightarrow>P(ll) )" by auto
  from 1 2 show "P []" by metis
qed

lemma list_induct_pre2:
  assumes 1:"( \<And> mm. (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm))" 
  shows " \<And> mm. (  (\<And> ll .(length(ll) < (length mm) \<Longrightarrow>P(ll)) )    \<Longrightarrow> P(mm)  ) \<Longrightarrow> (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )   "
proof -
  fix mm
  (*show "(  (\<And> ll .(length(ll) < (length mm) \<Longrightarrow>P(ll)) )    \<Longrightarrow> P(mm)  ) \<Longrightarrow> (\<And> ll .(length(ll) < (length mm) \<Longrightarrow>P(ll)) )"
    this one doesnt work,  bc isbella auto move goal \<And> to the begin*)
  have "(  (\<And> ll .(length(ll) < (length mm) \<Longrightarrow>P(ll)) )    \<Longrightarrow> P(mm)  ) \<Longrightarrow> ! ll. ( (length(ll) < (length mm) ) \<longrightarrow>P(ll) ) "
  proof (induct mm)
    show "((\<And>ll. length ll < length [] \<Longrightarrow> P ll) \<Longrightarrow> P []) \<Longrightarrow> (! ll. length ll < length [] \<longrightarrow> P ll)" by auto
  next
    show "\<And>a mmm. (((\<And>ll. length ll < length mmm \<Longrightarrow> P ll) \<Longrightarrow> P mmm) \<Longrightarrow>( ! ll .length ll < length mmm \<longrightarrow> P ll) ) \<Longrightarrow>
            ((\<And>ll. length ll < length (a # mmm) \<Longrightarrow> P ll) \<Longrightarrow> P (a # mmm)) \<Longrightarrow> (! ll. length ll < length (a # mmm) \<longrightarrow> P ll )"
    proof -
      fix a mmm
      assume 2:"(((\<And>ll. length ll < length mmm \<Longrightarrow> P ll) \<Longrightarrow> P mmm) \<Longrightarrow>( \<forall> ll. length ll < length mmm \<longrightarrow> P ll) )"
      assume 3:"((\<And>ll. length ll < length (a # mmm) \<Longrightarrow> P ll) \<Longrightarrow> P (a # mmm))"
      have 4: "\<And> ll. length ll < length (mmm) \<Longrightarrow> P ll" using 1 2 by metis
      have 5:"\<forall> ll. length ll = length (mmm) \<longrightarrow> P ll" using 1 4 by metis 
      show "\<forall> ll. length ll < length (a # mmm) \<longrightarrow> P ll"
      proof
        fix ll
        show "length ll < length (a # mmm) \<longrightarrow> P ll" 
        proof (cases)
          assume "length ll < length mmm"
          from this show "length ll < length (a # mmm) \<longrightarrow> P ll" using 4 by metis
        next
          assume assume1:"\<not> length ll < length mmm"
          show "length ll < length (a # mmm) \<longrightarrow> P ll"
          proof 
            assume "length ll < length (a # mmm)"
            from this assume1 have "length ll =length mmm" by auto
            from this 5 show "P ll" by auto
          qed
        qed
      qed
    qed
  qed
  from this show "(  (\<And> ll .(length(ll) < (length mm) \<Longrightarrow>P(ll)) )    \<Longrightarrow> P(mm)  ) \<Longrightarrow> (\<And> ll. ( (length(ll) < (length mm) ) \<Longrightarrow>P(ll) ) )"
    by metis
qed
 

lemma list_induct: 
  fixes n :: "nat"
  shows "  ( \<And> mm. (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm) )  \<Longrightarrow> P all   "
proof (induct all)
  case Nil
  then show ?case using list_induct_pre by metis
next
  show "\<And>la llt. ((\<And>mm. (\<And>ll. length ll < length mm \<Longrightarrow> P ll) \<Longrightarrow> P mm) \<Longrightarrow> P llt) \<Longrightarrow>
              (\<And>mm. (\<And>ll. length ll < length mm \<Longrightarrow> P ll) \<Longrightarrow> P mm) \<Longrightarrow> P (la # llt)"
  proof -
    fix la llt
    assume 1:"(\<And>mm. (\<And>ll. length ll < length mm \<Longrightarrow> P ll) \<Longrightarrow> P mm) \<Longrightarrow> P llt"
    assume 2:"(\<And>mm. (\<And>ll. length ll < length mm \<Longrightarrow> P ll) \<Longrightarrow> P mm)"
    from this list_induct_pre2 have 6:"\<And> mm. (  (\<And> ll .(length(ll) < (length mm) \<Longrightarrow>P(ll)) )    \<Longrightarrow> P(mm)  ) \<Longrightarrow> (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )"
      by metis
    from 1 2 have 3: "P llt" by metis
    from 2 have 4:"(\<And>ll. length ll < length (llt) \<Longrightarrow> P ll) \<Longrightarrow> P (llt)" by metis
    from 2 have 5:"(\<And>ll. length ll < length (la # llt) \<Longrightarrow> P ll) \<Longrightarrow> P (la # llt)" by metis
    from this 6 have "\<And> ll . ( length(ll) < (length (la# llt)) )  \<Longrightarrow>P(ll)" by metis
    from this 2 show "P (la # llt)" by metis
  qed
qed


thm length_induct

theorem msort_induct: "P [] \<Longrightarrow>
    (\<And>x. P [x]) \<Longrightarrow>
    (\<And>v vb vc.
        (\<And>x. x = length (v # vb # vc) div 2 \<Longrightarrow> P (take x (v # vb # vc))) \<Longrightarrow>
        (\<And>x. x = length (v # vb # vc) div 2 \<Longrightarrow> P (drop x (v # vb # vc))) \<Longrightarrow> P (v # vb # vc)) \<Longrightarrow>
    P all"
proof -
  assume r1:"P []"
  assume r2:"\<And>x. P [x]"
  assume r3:"\<And>v vb vc.
        (\<And>x. x = length (v # vb # vc) div 2 \<Longrightarrow> P (take x (v # vb # vc))) \<Longrightarrow>
        (\<And>x. x = length (v # vb # vc) div 2 \<Longrightarrow> P (drop x (v # vb # vc))) \<Longrightarrow> P (v # vb # vc)"
  have " ( \<And> mm. (\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm))"
  proof -
    fix mm
    show "(\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm)"
    proof (cases)
      assume "mm =[]"
      then show "(\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm)" using r1 by auto
    next
      assume ineq1:"~ (mm = []) "
      from this obtain ma mt where eq1:"ma= hd mm" "mt=(tl mm)" by auto
      from ineq1 this have eq2: "mm=(ma#mt)" by auto
      then have "(\<And> ll .(length(ll) < (length ( ma#mt) )  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(ma#mt)"
      proof (cases)
        assume "mt =[]"
        from this show "(\<And> ll .(length(ll) < (length ( ma#mt) )  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(ma#mt)" using r2 by metis
      next
        assume ineq2:"~ (mt= [])"
        from this obtain mb mtt where eq3:"mb= hd mt" "mtt=(tl mt)" by auto
        from this ineq2 have eq4: "mt=mb#mtt" by auto 
        have "(\<And> ll .(length(ll) < (length ( ma#mb#mtt) )  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(ma#mb#mtt) "
        proof -
          assume a1:"(\<And> ll .(length(ll) < (length ( ma#mb#mtt) )  \<Longrightarrow>P(ll)) )"
          have t1:" length ( take  ( length (ma # mb # mtt) div 2 )  (ma#mb#mtt) )  < length (ma # mb # mtt)" by auto
          have t2:" length ( drop  ( length (ma # mb # mtt) div 2 )  (ma#mb#mtt) )  < length (ma # mb # mtt)" by auto
          from r3 have " P ( take  ( length (ma # mb # mtt) div 2 )  (ma#mb#mtt))  \<Longrightarrow>
            P ( drop  ( length (ma # mb # mtt) div 2 )  (ma#mb#mtt))   \<Longrightarrow>  P(ma#mb#mtt)   " by metis
          from t1 a1 have t3: " P ( take  ( length (ma # mb # mtt) div 2 )  (ma#mb#mtt)) " by auto
          from t2 a1 have t4: " P ( drop ( length (ma # mb # mtt) div 2 )  (ma#mb#mtt)) " by auto
          from t3 t4 r3 show "P(ma#mb#mtt)" by metis
        qed
        from this eq4 show "(\<And> ll .(length(ll) < (length ( ma#mt) )  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(ma#mt)" by auto
      qed
      then show "(\<And> ll .(length(ll) < (length mm)  \<Longrightarrow>P(ll)) )  \<Longrightarrow> P(mm)" using eq2 by auto
    qed
  qed
  then show "P all" using list_induct by metis
qed
